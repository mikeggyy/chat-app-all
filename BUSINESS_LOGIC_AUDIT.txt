AI 聊天應用商業邏輯審查報告
===============================

生成日期: 2025-11-12
總體評分: 7.5/10 - 架構穩健但存在關鍵漏洞

發現 8 個問題:
- 3 個高危 (資料一致性、冪等性、消費邏輯)
- 5 個中危 (邏輯漏洞、邊界條件、重置機制)


===== 高危問題 (High Severity) =====

【問題1】對話消費與限制檢查的時序漏洞
位置: backend/src/ai/ai.routes.js 行131
問題: recordMessage() 沒有冪等性保護
- 網絡重試時可能重複計數
- 限制檢查與消費無 Transaction 保護
- 影響: 用戶被錯誤計數多次消費

改進: 
對話發送需要實現冪等性:
const requestId = `msg:${userId}:${characterId}:${messageHash}`;
await handleIdempotentRequest(requestId, async () => {
  await conversationLimitService.checkAndRecord(userId, characterId);
});


【問題2】廣告解鎖次數與基礎限制計數混亂
位置: backend/src/services/limitService/limitReset.js
問題:
- unlocked 字段既表示廣告解鎖又在重置時清零
- 廣告解鎖每日重置, 基礎限制月度/終生重置
- 導致同一用戶每天可重複觀看廣告獲得無限額外次數
- 影響: 免費用戶可繞過對話限制, 語音播放同樣受影響

改進:
將廣告解鎖改為有效期限制:
limitData.adUnlockExpireAt = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();

在檢查時驗證過期:
if (limitData.adUnlockExpireAt) {
  if (now >= new Date(limitData.adUnlockExpireAt)) {
    limitData.unlocked = 0;
  }
}


【問題3】金幣扣費與資產消費的不同步風險
位置: backend/src/payment/coins.service.js 行254-258
問題:
場景: 用戶有1張拍照卡
1. 發起購買請求→檢查到有卡片
2. 調用 usePhotoUnlockCard() 成功
3. 網絡中斷, 響應未返回
4. 客戶端重試→卡片已用完, 系統改為扣金幣
5. 用戶損失: 1張卡片 + 金幣
- 影響: 所有使用解鎖卡的購買場景

改進:
實現購買的完整冪等性:
return await handleIdempotentRequest(purchaseId, async () => {
  const cardResult = await tryUsePhotoCard(userId);
  if (cardResult.success) return cardResult;
  const coinResult = await deductCoins(userId, price);
  return coinResult;
});


===== 中危問題 (Medium Severity) =====

【問題4】會員升級時獎勵發放的不完整回滾
位置: backend/src/membership/membership.service.js 行258-380
問題:
- 預先計算拍照卡後才在 Transaction 中發放
- 如果用戶升級前後有其他對話操作, 計算可能不準確
- 重試時可能重複發放獎勵

改進: 將所有計算移入 Transaction 內


【問題5】限制查詢的日期邊界条件缺陷
位置: backend/src/services/limitService/limitReset.js 行38-45
問題:
- 使用 UTC 時間, 不考慮用戶本地時區
- 用戶在當地午夜時, UTC 時間已是次日
- 導致重置時機不符合用戶預期

改進: 實現用戶時區感知的重置


【問題6】交易記錄統計中的金額符號不一致
位置: backend/src/payment/transaction.service.js 行307-321
問題:
- SPEND 類型使用 Math.abs(amount), 但 REFUND 直接使用
- 導致統計數據不一致

改進: 統一金額符號規則


【問題7】解鎖票卡片消費的邊界條件
位置: backend/src/membership/unlockTickets.service.js
問題:
- 消費檢查不使用 Transaction
- 併發請求可能都通過檢查
- 卡片可能被多次消費

改進: 使用 Firestore Transaction 保護


【問題8】冪等性鍵的重複使用漏洞
位置: backend/src/utils/idempotency.js 行125-180
問題:
- 本地緩存 5 分鐘後過期
- 但 Firestore 記錄仍有效 (24 小時)
- 用戶在 5-24 小時間重試, 會再次執行操作

場景:
1. 用戶購買金幣 ¥100 (5分鐘緩存)
2. 5 分鐘後重試
3. 本地緩存過期, Firestore 檢查成功
4. 操作重複執行: 用戶被扣兩次 ¥100

改進: 統一 TTL 時間, 購買操作使用 7 天 TTL


===== 邏輯一致性問題 =====

前後端限制值可能差異
建議: 所有限制值從後端 API 動態獲取

會員降級邏輯未完整覆蓋
建議: 在每個消費操作前檢查會員有效期


===== 安全性審查 =====

✅ 整數溢出: 低風險, 建議限制最大值
✅ 用戶輸入驗證: 良好 (使用 Zod)
✅ 權限驗證: 良好 (從 token 獲取 userId)
✅ SQL 注入: 安全 (使用 Firestore, 非 SQL)


===== 數據一致性檢查 =====

操作                 Transaction  冪等性   狀態
送禮物                ✅         ✅      良好
購買金幣              ✅         ✅      良好
購買道具              ✅         ✅      良好
對話消息              ⚠️         ❌      需要改進
會員升級              ✅         ❌      需要改進
AI 拍照               ✅         ✅      良好
語音播放              ⚠️         ❌      需要改進


===== 優先級修復建議 =====

P0 (立即修復):
1. 對話消費冪等性
2. 廣告解鎖漏洞
3. 金幣扣費與資產同步

P1 (本週內):
4. 會員升級冪等性
5. 廣告重置時區問題
6. 冪等性 TTL 同步
7. 解鎖票卡片 Transaction

P2 (計劃修復):
8. 交易統計金額符號
9. 限制查詢邊界條件
10. 整數溢出保護


===== 測試建議 =====

關鍵測試場景:
1. 重複發送同一消息不應重複扣費
2. 廣告解鎖應在 24 小時後失效
3. 購買流程: 金幣 → 完整操作 → 驗證 log
4. 網絡中斷恢復: 模擬失敗, 驗證冪等性
5. 併發操作: 同時發送多個請求, 驗證資產不重複扣除


===== 結論 =====

整體結構良好, 使用了 Firestore Transaction 和冪等性機制。
但存在需改進的地方:

1. 對話系統缺乏冪等性保護 (最高優先級)
2. 廣告解鎖機制存在漏洞 (可被無限重複使用)
3. 部分消費操作的原子性不完整 (導致資料不一致)

建議立即修復 P0 級別問題, 然後系統性改進其他問題。
增加自動化測試覆蓋這些場景。
