<script setup lang="ts">
import {
  computed,
  nextTick,
  onBeforeUnmount,
  onMounted,
  reactive,
  ref,
  watch,
} from "vue";
import type { Ref, ComputedRef } from "vue";
import { useRouter, useRoute } from "vue-router";
import {
  fetchCharacterCreationFlow,
  readStoredCharacterCreationFlowId,
  generateCharacterPersonaWithAI,
  generateCharacterImages,
} from "../services/characterCreation.service.js";
import { useGenderPreference } from "../composables/useGenderPreference.js";
import { useCharacterCreationFlow } from "../composables/useCharacterCreationFlow.js";
import { useDraftFlow } from "../composables/character-creation/useDraftFlow.js";
import { CHARACTER_CREATION_LIMITS } from "../config/characterCreation.js";
import { useToast } from "../composables/useToast.js";
import { useConfirmDialog } from "../composables/useConfirmDialog.js";
import GeneratingHeader from "../components/character-creation/GeneratingHeader.vue";
import ProgressStep from "../components/character-creation/ProgressStep.vue";
import SelectionStep from "../components/character-creation/SelectionStep.vue";
import SettingsStep from "../components/character-creation/SettingsStep.vue";
import GeneratingFooter from "../components/character-creation/GeneratingFooter.vue";

// Types
interface GeneratedResult {
  id: string;
  label: string;
  image: string;
  alt: string;
  name: string;
  tagline: string;
  prompt: string;
}

interface PersonaForm {
  name: string;
  tagline: string;
  hiddenProfile: string;
  prompt: string;
}

interface FlowRecord {
  generation?: {
    result?: {
      images?: Array<{ url: string; [key: string]: any }>;
    };
  };
  [key: string]: any;
}

interface GenerateImagesOptions {
  quality: string;
  count: number;
}

interface GenerateImagesResponse {
  images: Array<{ url: string; [key: string]: any }>;
  flow: FlowRecord;
}

interface PersonaResponse {
  name?: string;
  tagline?: string;
  hiddenProfile?: string;
  prompt?: string;
}

const router = useRouter();
const route = useRoute();
const { error: showErrorToast } = useToast();

// å¸¸é‡å®šç¾©
const Step = Object.freeze({
  PROGRESS: "progress",
  SELECTION: "selection",
  SETTINGS: "settings",
} as const);

type StepType = typeof Step[keyof typeof Step];

// âœ… ä½¿ç”¨é›†ä¸­åŒ–é…ç½®ï¼ˆå¾ config/characterCreation.js å°å…¥ï¼‰
const MAX_NAME_LENGTH: number = CHARACTER_CREATION_LIMITS.MAX_NAME_LENGTH;
const MAX_TAGLINE_LENGTH: number = CHARACTER_CREATION_LIMITS.MAX_TAGLINE_LENGTH;
const MAX_PROMPT_LENGTH: number = CHARACTER_CREATION_LIMITS.MAX_PROMPT_LENGTH;
const MAX_HIDDEN_PROFILE_LENGTH: number = CHARACTER_CREATION_LIMITS.MAX_HIDDEN_PROFILE_LENGTH;

// é€²åº¦æ¢ç‹€æ…‹
const progress: Ref<number> = ref(18);
const isAnimating: Ref<boolean> = ref(false);
let progressTimer: number | null = null;

// ç”Ÿæˆçµæœ
const generatedResults: Ref<GeneratedResult[]> = ref([]);
const selectedResultId: Ref<string> = ref("");
const generatingEmblem: string = "/character-create/generating-emblem.png";

// ç•¶å‰æ­¥é©Ÿ
const currentStep: Ref<StepType> = ref(Step.PROGRESS);

// è¡¨å–®æ•¸æ“š
const personaForm: PersonaForm = reactive({
  name: "",
  tagline: "",
  hiddenProfile: "",
  prompt: "",
});

// ä½¿ç”¨ Gender Preference Composable
const {
  genderPreference,
  normalizeGenderPreference,
  readStoredGenderPreference,
  ensureGenderPreference,
} = useGenderPreference();

// AI ç›¸é—œç‹€æ…‹
const isAIMagicianLoading: Ref<boolean> = ref(false);
const aiMagicianError: Ref<string | null> = ref(null);
const isGeneratingImages: Ref<boolean> = ref(false);
const imageGenerationError: Ref<string | null> = ref(null);

// AI é­”æ³•å¸«ä½¿ç”¨æ¬¡æ•¸ï¼ˆèˆ‡ appearance é é¢ä¿æŒä¸€è‡´ï¼‰
const AI_MAGICIAN_LIMIT = 3;
const aiMagicianUsageCount: Ref<number> = ref(0);

// è‰ç¨¿æµç¨‹ç®¡ç†
const {
  hasDraft,
  draftFlow,
  checkDraft,
  saveDraft,
  clearDraft,
  updateDraftStep,
} = useDraftFlow();

// ç¢ºèªå°è©±æ¡†
const { confirm } = useConfirmDialog();

// æ˜¯å¦å·²ç”Ÿæˆåœ–ç‰‡ï¼ˆç”¨æ–¼åˆ¤æ–·æ˜¯å¦éœ€è¦ä¿å­˜è‰ç¨¿ï¼‰
const hasGeneratedImages: Ref<boolean> = ref(false);

// Computed å±¬æ€§
const isComplete: ComputedRef<boolean> = computed(() => progress.value >= 100);
const progressText: ComputedRef<string> = computed(() => `${progress.value}%`);
const statusText: ComputedRef<string> = computed(() =>
  progress.value >= 100 ? "è§’è‰²ç”Ÿæˆå®Œæˆï¼" : "è§’è‰²ç”Ÿæˆä¸­"
);

const isSelectionStep: ComputedRef<boolean> = computed(() => currentStep.value === Step.SELECTION);
const isSettingsStep: ComputedRef<boolean> = computed(() => currentStep.value === Step.SETTINGS);

const headerTitle: ComputedRef<string> = computed(() => {
  if (currentStep.value === Step.SETTINGS) {
    return "è§’è‰²è¨­å®š";
  }
  if (currentStep.value === Step.SELECTION) {
    return "";
  }
  return "";
});

const selectedResult: ComputedRef<GeneratedResult | null> = computed(() => {
  return (
    generatedResults.value.find(
      (result) => result.id === selectedResultId.value
    ) ??
    generatedResults.value[0] ??
    null
  );
});

const selectedResultImage: ComputedRef<string> = computed(() => selectedResult.value?.image ?? "");
const selectedResultAlt: ComputedRef<string> = computed(
  () =>
    selectedResult.value?.alt ?? selectedResult.value?.label ?? "ç”Ÿæˆè§’è‰²é è¦½"
);
const selectedResultLabel: ComputedRef<string> = computed(() => selectedResult.value?.label ?? "");

const nameLength: ComputedRef<number> = computed(() => personaForm.name.length);
const taglineLength: ComputedRef<number> = computed(() => personaForm.tagline.length);
const hiddenProfileLength: ComputedRef<number> = computed(() => personaForm.hiddenProfile.length);
const promptLength: ComputedRef<number> = computed(() => personaForm.prompt.length);

const aiMagicianRemainingUsage: ComputedRef<number> = computed(() => {
  return Math.max(0, AI_MAGICIAN_LIMIT - aiMagicianUsageCount.value);
});

const confirmButtonLabel: ComputedRef<string> = computed(() => {
  if (currentStep.value === Step.SELECTION) {
    return "ä¸‹ä¸€æ­¥";
  }
  if (currentStep.value === Step.SETTINGS) {
    return "ä¸‹ä¸€æ­¥";
  }
  return "ç¢ºèª";
});

const isConfirmDisabled: ComputedRef<boolean> = computed(() => {
  if (currentStep.value === Step.PROGRESS) {
    return true;
  }
  if (currentStep.value === Step.SELECTION) {
    return !selectedResultId.value;
  }
  if (currentStep.value === Step.SETTINGS) {
    return (
      personaForm.name.trim().length === 0 ||
      personaForm.tagline.trim().length === 0 ||
      personaForm.hiddenProfile.trim().length === 0 ||
      personaForm.prompt.trim().length === 0
    );
  }
  return true;
});

// ä½¿ç”¨ Character Creation Flow Composable
const {
  flowId,
  buildSummaryPayload,
  persistSummaryToSession,
  applyFlowRecord,
  syncSummaryToBackend,
  scheduleBackendSync,
  initializeFlowState,
  cleanup: cleanupFlow,
  getSuppressSync,
  setSuppressSync,
} = useCharacterCreationFlow({
  personaForm,
  selectedResult: selectedResult as any,
  selectedResultId,
  selectedResultLabel,
  selectedResultImage,
  selectedResultAlt,
  genderPreference,
  normalizeGenderPreference: normalizeGenderPreference as any,
  readStoredGenderPreference: readStoredGenderPreference as any,
  ensureGenderPreference: ensureGenderPreference as any,
  currentStep,
});

// å·¥å…·å‡½æ•¸
const stopTimer = (): void => {
  if (progressTimer !== null) {
    window.clearInterval(progressTimer);
    progressTimer = null;
  }
};

const beginProgressAnimation = (): void => {
  if (typeof window === "undefined" || isAnimating.value) {
    return;
  }
  isAnimating.value = true;
  progressTimer = window.setInterval(() => {
    // åœ–ç‰‡ç”Ÿæˆéœ€è¦è¼ƒé•·æ™‚é–“ï¼Œé€²åº¦æ¢è¦æ…¢ä¸€äº›
    // ä¸¦ä¸”ä¸è¦è¶…é 90%ï¼Œæœ€å¾Œ 10% ç­‰å¯¦éš›å®Œæˆ
    const increment =
      progress.value < 50
        ? Math.ceil(Math.random() * 3) // å‰åŠæ®µç¨å¿« (1-3%)
        : Math.ceil(Math.random() * 2); // å¾ŒåŠæ®µå¾ˆæ…¢ (1-2%)

    progress.value = Math.min(90, progress.value + increment);

    // ä¸å†è‡ªå‹•å®Œæˆï¼Œç­‰å¾…å¯¦éš› API å®Œæˆ
  }, 1500); // æ”¹ç‚º 1.5 ç§’ä¸€æ¬¡ï¼Œè®“å‹•ç•«æ›´æ…¢æ›´çœŸå¯¦
};

// beforeunload è™•ç†å‡½æ•¸
const handleBeforeUnload = (event: BeforeUnloadEvent): string => {
  event.preventDefault();
  event.returnValue = ""; // Chrome éœ€è¦è¨­ç½® returnValue
  return ""; // éƒ¨åˆ†ç€è¦½å™¨éœ€è¦è¿”å›å­—ä¸²
};

const triggerImageGeneration = async (): Promise<void> => {
  // ç¢ºä¿ flowId å·²ç¶“åˆå§‹åŒ–
  if (!flowId.value) {
    // å˜—è©¦å¾ localStorage è®€å–
    const storedFlowId = readStoredCharacterCreationFlowId();
    if (storedFlowId) {
      flowId.value = storedFlowId;
    } else {
      const errorMessage = "æ‰¾ä¸åˆ°è§’è‰²å‰µå»ºæµç¨‹ï¼Œè«‹è¿”å›é‡æ–°é–‹å§‹";
      imageGenerationError.value = errorMessage;

      // ğŸ”¥ é¡¯ç¤ºéŒ¯èª¤æç¤ºä¸¦è¿”å›åˆ° appearance é é¢
      showErrorToast(errorMessage, {
        title: "å‰µå»ºæµç¨‹éŒ¯èª¤",
        duration: 5000,
      });

      setTimeout(() => {
        router.push({ name: "character-create-appearance" }).catch(() => {
          // Silent fail
        });
      }, 1000);
      return;
    }
  }

  if (isGeneratingImages.value) {
    return;
  }

  try {
    isGeneratingImages.value = true;
    imageGenerationError.value = null;

    // åŠ å…¥ beforeunload ç›£è½ï¼Œè­¦å‘Šç”¨æˆ¶ä¸è¦åˆ·æ–°æˆ–é—œé–‰é é¢
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", handleBeforeUnload);
    }

    const { images, flow: updatedFlow } = await generateCharacterImages(
      flowId.value,
      {
        quality: "standard",
        count: 4,
      } as GenerateImagesOptions
    ) as GenerateImagesResponse;

    if (images && images.length > 0) {
      // å°‡ç”Ÿæˆçš„åœ–ç‰‡æ›´æ–°åˆ° generatedResults
      generatedResults.value = images.map((img, index) => ({
        id: `generated-${index}`,
        label: `é¢¨æ ¼ ${index + 1}`,
        image: img.url,
        alt: `ç”Ÿæˆçš„è§’è‰²å½¢è±¡ ${index + 1}`,
        name: "",
        tagline: "",
        prompt: "",
      }));

      // è‡ªå‹•é¸æ“‡ç¬¬ä¸€å¼µåœ–ç‰‡
      if (!selectedResultId.value && generatedResults.value.length > 0) {
        selectedResultId.value = generatedResults.value[0].id;
      }

      // æ›´æ–° flow è¨˜éŒ„
      if (updatedFlow) {
        applyFlowRecord(updatedFlow as any);
      }

      // âœ… åœ–ç‰‡ç”ŸæˆæˆåŠŸå¾Œï¼Œæ¸…é™¤æ‰€æœ‰æ€§åˆ¥çš„ AI é­”æ³•å¸«ä½¿ç”¨æ¬¡æ•¸
      if (typeof window !== "undefined" && window.sessionStorage) {
        try {
          ['male', 'female', 'non-binary'].forEach((gender: string): void => {
            window.sessionStorage.removeItem(`ai-magician-usage-${gender}`);
          });
          // é‡ç½®ç•¶å‰è¨ˆæ•¸å™¨
          aiMagicianUsageCount.value = 0;
          console.log('[CharacterCreateGeneratingView] AI é­”æ³•å¸«ä½¿ç”¨æ¬¡æ•¸å·²é‡ç½®');
        } catch (error) {
          console.error('[CharacterCreateGeneratingView] æ¸…é™¤ AI é­”æ³•å¸«ä½¿ç”¨æ¬¡æ•¸å¤±æ•—', error);
        }
      }

      // âœ… æ¨™è¨˜å·²ç”Ÿæˆåœ–ç‰‡
      hasGeneratedImages.value = true;

      // âœ… ä¿å­˜è‰ç¨¿ï¼ˆå› ç‚ºå·²ç¶“æ‰£éŒ¢ç”Ÿæˆåœ–ç‰‡äº†ï¼‰
      if (flowId.value) {
        try {
          saveDraft({
            flowId: flowId.value,
            createdAt: new Date().toISOString(),
            step: "generating", // ç•¶å‰åœ¨ç”Ÿæˆé é¢
            hasGeneratedImages: true,
          });
          console.log('[CharacterCreateGeneratingView] è‰ç¨¿å·²è‡ªå‹•ä¿å­˜');
        } catch (error) {
          console.error('[CharacterCreateGeneratingView] ä¿å­˜è‰ç¨¿å¤±æ•—', error);
        }
      }
    } else {
      throw new Error("æœªèƒ½ç”Ÿæˆä»»ä½•åœ–ç‰‡");
    }
  } catch (error: any) {
    const errorMessage = error?.message || "åœ–ç‰‡ç”Ÿæˆå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦";
    imageGenerationError.value = errorMessage;

    // ç”Ÿæˆå¤±æ•—æ™‚åœæ­¢é€²åº¦å‹•ç•«
    stopTimer();

    // ğŸ”¥ é¡¯ç¤ºéŒ¯èª¤æç¤ºä¸¦è¿”å›åˆ° appearance é é¢
    showErrorToast(errorMessage, {
      title: "åœ–ç‰‡ç”Ÿæˆå¤±æ•—",
      duration: 5000,
    });

    // å»¶é² 1 ç§’å¾Œè¿”å›åˆ° appearance é é¢
    setTimeout(() => {
      router.push({ name: "character-create-appearance" }).catch(() => {
        // Silent fail
      });
    }, 1000);
  } finally {
    isGeneratingImages.value = false;
    // ç§»é™¤ beforeunload ç›£è½
    if (typeof window !== "undefined") {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    }
  }
};

const applyResultToPersona = (result: GeneratedResult | null): void => {
  setSuppressSync(true);
  const fallbackName = result?.name || "";
  personaForm.name = fallbackName.slice(0, MAX_NAME_LENGTH);

  const fallbackTagline = result?.tagline || "";
  personaForm.tagline = fallbackTagline.slice(0, MAX_TAGLINE_LENGTH);

  personaForm.hiddenProfile = "";

  const fallbackPrompt = result?.prompt || "";
  personaForm.prompt = fallbackPrompt.slice(0, MAX_PROMPT_LENGTH);
  setSuppressSync(false);
  scheduleBackendSync();
};

const handleBack = async (): Promise<void> => {
  console.log('[GeneratingView] handleBack è¢«èª¿ç”¨', {
    currentStep: currentStep.value,
    Step_SETTINGS: Step.SETTINGS,
    timestamp: new Date().toISOString()
  });

  // æ ¹æ“šç•¶å‰æ­¥é©Ÿè¿”å›åˆ°æ­£ç¢ºçš„é é¢
  if (currentStep.value === Step.SETTINGS) {
    // ğŸ”¥ å¾è¨­å®šæ­¥é©Ÿè¿”å›æ™‚ï¼Œè©¢å•æ˜¯å¦ä¿å­˜ç·¨è¼¯
    const hasEditedContent =
      personaForm.name.trim().length > 0 ||
      personaForm.tagline.trim().length > 0 ||
      personaForm.hiddenProfile.trim().length > 0 ||
      personaForm.prompt.trim().length > 0;

    console.log('[GeneratingView] hasEditedContent:', hasEditedContent, {
      name: personaForm.name.trim().length,
      tagline: personaForm.tagline.trim().length,
      hiddenProfile: personaForm.hiddenProfile.trim().length,
      prompt: personaForm.prompt.trim().length
    });

    if (hasEditedContent) {
      console.log('[GeneratingView] æº–å‚™é¡¯ç¤ºç¢ºèªå°è©±æ¡†');
      const shouldSave = await confirm({
        title: "ä¿å­˜ç·¨è¼¯å…§å®¹ï¼Ÿ",
        message: "æ‚¨å·²ç¶“å¡«å¯«äº†è§’è‰²è¨­å®šå…§å®¹ã€‚æ˜¯å¦è¦ä¿ç•™æ­¤æ¬¡ç·¨è¼¯é€²åº¦ï¼Ÿ",
        confirmText: "ä¿å­˜é€²åº¦",
        cancelText: "æ”¾æ£„ç·¨è¼¯",
      });

      console.log('[GeneratingView] ç”¨æˆ¶é¸æ“‡:', shouldSave ? 'ä¿å­˜' : 'æ”¾æ£„');

      if (shouldSave) {
        // ç”¨æˆ¶é¸æ“‡ä¿å­˜è‰ç¨¿ - åŒæ­¥åˆ°å¾Œç«¯
        if (flowId.value) {
          try {
            await syncSummaryToBackend({} as any);
            console.log('[CharacterCreateGeneratingView] ç”¨æˆ¶é¸æ“‡ä¿å­˜è¨­å®šè‰ç¨¿');
          } catch (error) {
            console.error('[CharacterCreateGeneratingView] ä¿å­˜è¨­å®šè‰ç¨¿å¤±æ•—', error);
          }
        }
      } else {
        // ç”¨æˆ¶é¸æ“‡æ”¾æ£„ç·¨è¼¯ - æ¸…ç©ºè¡¨å–®ï¼ˆå¯é¸ï¼‰
        console.log('[CharacterCreateGeneratingView] ç”¨æˆ¶é¸æ“‡æ”¾æ£„è¨­å®šç·¨è¼¯');
      }
    }

    // è¿”å›åˆ°é¸æ“‡æ­¥é©Ÿ
    console.log('[GeneratingView] æº–å‚™è¿”å›åˆ°é¸æ“‡æ­¥é©Ÿ');
    currentStep.value = Step.SELECTION;
    if (typeof window !== "undefined") {
      window.scrollTo({ top: 0, behavior: "smooth" });
    }
    console.log('[GeneratingView] å·²åˆ‡æ›åˆ°é¸æ“‡æ­¥é©Ÿ');
    return;
  }

  if (currentStep.value === Step.SELECTION) {
    // âœ… å¦‚æœå·²ç¶“ç”Ÿæˆåœ–ç‰‡ï¼Œè©¢å•æ˜¯å¦ä¿å­˜è‰ç¨¿
    if (hasGeneratedImages.value) {
      const shouldSave = await confirm({
        title: "ä¿å­˜ç·¨è¼¯é€²åº¦ï¼Ÿ",
        message: "æ‚¨å·²ç¶“ç”Ÿæˆäº†è§’è‰²åœ–ç‰‡ä¸¦æ¶ˆè€—äº†ç›¸æ‡‰é¡åº¦ã€‚æ˜¯å¦è¦ä¿ç•™æ­¤æ¬¡ç·¨è¼¯é€²åº¦ï¼Œä¸‹æ¬¡å¯ä»¥ç¹¼çºŒç·¨è¼¯ï¼Ÿ",
        confirmText: "ä¿å­˜é€²åº¦",
        cancelText: "æ”¾æ£„é€²åº¦",
      });

      if (shouldSave) {
        // ç”¨æˆ¶é¸æ“‡ä¿å­˜è‰ç¨¿
        if (flowId.value) {
          try {
            saveDraft({
              flowId: flowId.value,
              createdAt: new Date().toISOString(),
              step: "generating",
              hasGeneratedImages: true,
            });
            console.log('[CharacterCreateGeneratingView] ç”¨æˆ¶é¸æ“‡ä¿å­˜è‰ç¨¿');
          } catch (error) {
            console.error('[CharacterCreateGeneratingView] ä¿å­˜è‰ç¨¿å¤±æ•—', error);
          }
        }
      } else {
        // ç”¨æˆ¶é¸æ“‡æ”¾æ£„è‰ç¨¿
        clearDraft();
        console.log('[CharacterCreateGeneratingView] ç”¨æˆ¶é¸æ“‡æ”¾æ£„è‰ç¨¿');
      }
    }

    // è¿”å›åˆ°å¤–è§€é é¢ï¼ˆé¸æ“‡ç…§ç‰‡é é¢ï¼‰
    router.push({ name: "character-create-appearance" }).catch(() => {
      // Silent fail
    });
    return;
  }

  // å…¶ä»–æƒ…æ³è¿”å›åˆ° profile é é¢
  router.push({ name: "profile" }).catch(() => {
    // Silent fail
  });
};

const persistCreationSummary = async (): Promise<void> => {
  const summary = buildSummaryPayload();
  persistSummaryToSession(summary);

  try {
    await syncSummaryToBackend({
      summary,
      statusOverride: "voice",
    });
  } catch {
    // åŒæ­¥æ™‚å·²åœ¨å‡½å¼å…§è™•ç†éŒ¯èª¤
  }
};

const enterSettingsStep = (): void => {
  applyResultToPersona(selectedResult.value);
  currentStep.value = Step.SETTINGS;
  if (typeof window !== "undefined") {
    window.scrollTo({ top: 0, behavior: "smooth" });
  }
};

const handleConfirm = async (): Promise<void> => {
  if (currentStep.value === Step.SELECTION) {
    if (!selectedResultId.value) {
      return;
    }
    // åœ¨é€²å…¥è¨­å®šæ­¥é©Ÿå‰ï¼Œå…ˆåŒæ­¥é¸æ“‡çš„å¤–è§€åˆ°å¾Œç«¯
    await syncSummaryToBackend({} as any);
    enterSettingsStep();
    return;
  }

  if (currentStep.value === Step.SETTINGS) {
    if (isConfirmDisabled.value) {
      return;
    }
    await persistCreationSummary();
    router.push({ name: "character-create-voice" }).catch(() => {
      // Silent fail
    });
    return;
  }
};

const handleResultSelect = (resultId: string): void => {
  if (currentStep.value !== Step.SELECTION || !resultId) {
    return;
  }
  selectedResultId.value = resultId;
  // åªä¿å­˜åˆ°æœ¬åœ° sessionStorageï¼Œä¸ç™¼é€ API è«‹æ±‚
  const summary = buildSummaryPayload();
  persistSummaryToSession(summary);
};

const openAIMagician = async (): Promise<void> => {
  console.log('[GeneratingView] openAIMagician è¢«èª¿ç”¨', {
    isLoading: isAIMagicianLoading.value,
    flowId: flowId.value,
    selectedResultId: selectedResultId.value,
    timestamp: new Date().toISOString()
  });

  if (isAIMagicianLoading.value) {
    console.log('[GeneratingView] å·²ç¶“åœ¨ç”Ÿæˆä¸­ï¼Œè¿”å›');
    return;
  }

  if (!flowId.value) {
    const errorMessage = "è«‹å…ˆå®Œæˆå‰é¢çš„æ­¥é©Ÿ";
    aiMagicianError.value = errorMessage;
    console.log('[GeneratingView] ç¼ºå°‘ flowId:', errorMessage);
    showErrorToast(errorMessage, {
      title: "AIé­”æ³•å¸«",
      duration: 3000,
    });
    return;
  }

  if (!selectedResultId.value) {
    const errorMessage = "è«‹å…ˆé¸æ“‡è§’è‰²å¤–è§€";
    aiMagicianError.value = errorMessage;
    console.log('[GeneratingView] ç¼ºå°‘ selectedResultId:', errorMessage);
    showErrorToast(errorMessage, {
      title: "AIé­”æ³•å¸«",
      duration: 3000,
    });
    return;
  }

  try {
    // ğŸ”¥ ä¿®å¾©ï¼šå®Œå…¨ç…§æŠ„ useAIMagician çš„æ¨¡å¼
    console.log('[GeneratingView] è¨­ç½® isAIMagicianLoading = true');
    isAIMagicianLoading.value = true;
    aiMagicianError.value = null;
    console.log('[GeneratingView] isAIMagicianLoading ç•¶å‰å€¼:', isAIMagicianLoading.value);

    const persona = await generateCharacterPersonaWithAI(flowId.value) as PersonaResponse;

    if (persona) {
      setSuppressSync(true);
      personaForm.name = persona.name || "";
      personaForm.tagline = persona.tagline || "";
      personaForm.hiddenProfile = persona.hiddenProfile || "";
      personaForm.prompt = persona.prompt || "";
      setSuppressSync(false);

      // æ›´æ–°ä½¿ç”¨æ¬¡æ•¸
      aiMagicianUsageCount.value = (aiMagicianUsageCount.value || 0) + 1;

      scheduleBackendSync({} as any);
    }
  } catch (error: any) {
    const errorMessage = error?.message || "AI é­”æ³•å¸«ç”Ÿæˆå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦";
    aiMagicianError.value = errorMessage;
    showErrorToast(errorMessage, {
      title: "AIé­”æ³•å¸«å¤±æ•—",
      duration: 5000,
    });
  } finally {
    console.log('[GeneratingView] è¨­ç½® isAIMagicianLoading = false');
    isAIMagicianLoading.value = false;
  }
};

// ğŸ”¥ èª¿è©¦ï¼šç›£è½ isAIMagicianLoading è®ŠåŒ–
watch(() => isAIMagicianLoading.value, (newVal, oldVal) => {
  console.log('[GeneratingView] isAIMagicianLoading è®ŠåŒ–:', {
    old: oldVal,
    new: newVal,
    timestamp: new Date().toISOString()
  });
}, { immediate: true });

watch(
  () => route.query.step,
  (step) => {
    if (step === "settings") {
      currentStep.value = Step.SETTINGS;
      return;
    }
    if (step === "selection") {
      currentStep.value = Step.SELECTION;
    }
  },
  { immediate: true }
);

// å‰µå»ºè¡¨å–®æ¬„ä½ watcher çš„å·¥å…·å‡½æ•¸ï¼ˆé¿å…é‡è¤‡ä»£ç¢¼ï¼‰
const createFieldWatcher = (fieldName: keyof PersonaForm, maxLength: number) => {
  return (value: string): void => {
    if (getSuppressSync()) return;

    if (typeof value !== "string") {
      setSuppressSync(true);
      personaForm[fieldName] = "";
      setSuppressSync(false);
      scheduleBackendSync();
      return;
    }

    if (value.length > maxLength) {
      setSuppressSync(true);
      personaForm[fieldName] = value.slice(0, maxLength);
      setSuppressSync(false);
      scheduleBackendSync();
      return;
    }

    scheduleBackendSync();
  };
};

// ç‚ºæ¯å€‹è¡¨å–®æ¬„ä½å‰µå»º watcher
watch(() => personaForm.name, createFieldWatcher("name", MAX_NAME_LENGTH));
watch(() => personaForm.tagline, createFieldWatcher("tagline", MAX_TAGLINE_LENGTH));
watch(() => personaForm.hiddenProfile, createFieldWatcher("hiddenProfile", MAX_HIDDEN_PROFILE_LENGTH));
watch(() => personaForm.prompt, createFieldWatcher("prompt", MAX_PROMPT_LENGTH));

watch(
  () => isComplete.value,
  (complete) => {
    if (complete && currentStep.value === Step.PROGRESS) {
      currentStep.value = Step.SELECTION;
    }
  }
);

onMounted(() => {
  initializeFlowState().finally(async () => {
    // âœ… æª¢æŸ¥æ˜¯å¦æœ‰è‰ç¨¿éœ€è¦æ¢å¾©
    const draft = checkDraft();
    if (draft && draft.hasGeneratedImages) {
      // æœ‰è‰ç¨¿ï¼Œæ¢å¾© flowId
      flowId.value = draft.flowId;
      hasGeneratedImages.value = true;
      console.log('[CharacterCreateGeneratingView] å¾è‰ç¨¿æ¢å¾© flowId:', draft.flowId);
    }

    // ç¢ºä¿ flowId å·²åˆå§‹åŒ–
    if (!flowId.value) {
      const storedFlowId = readStoredCharacterCreationFlowId();
      if (storedFlowId) {
        flowId.value = storedFlowId;
      } else {
        const errorMessage = "æ‰¾ä¸åˆ°è§’è‰²å‰µå»ºæµç¨‹ï¼Œè«‹è¿”å›é‡æ–°é–‹å§‹";
        imageGenerationError.value = errorMessage;

        // ğŸ”¥ é¡¯ç¤ºéŒ¯èª¤æç¤ºä¸¦è¿”å›åˆ° appearance é é¢
        showErrorToast(errorMessage, {
          title: "å‰µå»ºæµç¨‹éŒ¯èª¤",
          duration: 5000,
        });

        setTimeout(() => {
          router.push({ name: "character-create-appearance" }).catch(() => {
            // Silent fail
          });
        }, 1000);
        return;
      }
    }

    // æª¢æŸ¥æ˜¯å¦å·²æœ‰ç”Ÿæˆçš„åœ–ç‰‡
    const currentFlow = await fetchCharacterCreationFlow(flowId.value).catch(
      () => {
        return null;
      }
    ) as FlowRecord | null;

    if (!currentFlow) {
      const errorMessage = "æ‰¾ä¸åˆ°è§’è‰²å‰µå»ºæµç¨‹ï¼Œè«‹è¿”å›é‡æ–°é–‹å§‹";
      imageGenerationError.value = errorMessage;

      // ğŸ”¥ é¡¯ç¤ºéŒ¯èª¤æç¤ºä¸¦è¿”å›åˆ° appearance é é¢
      showErrorToast(errorMessage, {
        title: "å‰µå»ºæµç¨‹éŒ¯èª¤",
        duration: 5000,
      });

      setTimeout(() => {
        router.push({ name: "character-create-appearance" }).catch(() => {
          // Silent fail
        });
      }, 1000);
      return;
    }

    // åŒæ­¥ AI é­”æ³•å¸«ä½¿ç”¨æ¬¡æ•¸
    if (currentFlow?.metadata?.aiMagicianUsageCount !== undefined) {
      aiMagicianUsageCount.value = currentFlow.metadata.aiMagicianUsageCount;
    }

    const flowHasGeneratedImages =
      (currentFlow?.generation?.result?.images?.length ?? 0) > 0;

    if (flowHasGeneratedImages) {
      // âœ… æ¨™è¨˜å·²ç”Ÿæˆåœ–ç‰‡
      hasGeneratedImages.value = true;

      // å¦‚æœå·²æœ‰ç”Ÿæˆçš„åœ–ç‰‡ï¼Œç›´æ¥ä½¿ç”¨
      const images = currentFlow.generation!.result!.images!;
      generatedResults.value = images.map((img, index) => ({
        id: `generated-${index}`,
        label: `é¢¨æ ¼ ${index + 1}`,
        image: img.url,
        alt: `ç”Ÿæˆçš„è§’è‰²å½¢è±¡ ${index + 1}`,
        name: "",
        tagline: "",
        prompt: "",
      }));

      if (!selectedResultId.value && generatedResults.value.length) {
        selectedResultId.value = generatedResults.value[0].id;
        scheduleBackendSync();
      }

      // ç«‹å³å®Œæˆé€²åº¦
      progress.value = 100;
    } else {
      // é–‹å§‹é€²åº¦å‹•ç•«ï¼ˆæœƒæ…¢æ…¢åˆ° 90%ï¼‰
      beginProgressAnimation();

      // è§¸ç™¼åœ–åƒç”Ÿæˆ
      await triggerImageGeneration();

      // ç”Ÿæˆå®Œæˆå¾Œï¼Œåœæ­¢å‹•ç•«ä¸¦è·³åˆ° 100%
      stopTimer();
      progress.value = 100;
    }
  });
});

onBeforeUnmount(() => {
  stopTimer();
  cleanupFlow(); // æ¸…ç† composable ä¸­çš„å®šæ™‚å™¨
  // ç¢ºä¿ç§»é™¤ beforeunload ç›£è½
  if (typeof window !== "undefined") {
    window.removeEventListener("beforeunload", handleBeforeUnload);
  }
});
</script>

<template>
  <div
    class="generating"
    :class="{
      'generating--complete': isComplete,
      'generating--settings': isSettingsStep,
    }"
    role="dialog"
    aria-modal="true"
  >
    <GeneratingHeader
      :current-step="currentStep"
      :settings-step-value="Step.SETTINGS"
      :title="headerTitle"
      @back="handleBack"
    />

    <ProgressStep
      v-if="currentStep === Step.PROGRESS"
      :progress="progress"
      :progress-text="progressText"
      :status-text="statusText"
      :is-complete="isComplete"
      :is-generating-images="isGeneratingImages"
      :image-generation-error="imageGenerationError"
      :generating-emblem="generatingEmblem"
    />

    <SelectionStep
      v-else-if="currentStep === Step.SELECTION"
      :selected-result-image="selectedResultImage"
      :selected-result-alt="selectedResultAlt"
      :generated-results="generatedResults"
      :selected-result-id="selectedResultId"
      :is-selection-step="isSelectionStep"
      @select="handleResultSelect"
    />

    <SettingsStep
      v-else
      :selected-result-image="selectedResultImage"
      :selected-result-alt="selectedResultAlt"
      :persona-form="personaForm"
      :name-length="nameLength"
      :tagline-length="taglineLength"
      :hidden-profile-length="hiddenProfileLength"
      :prompt-length="promptLength"
      :max-name-length="MAX_NAME_LENGTH"
      :max-tagline-length="MAX_TAGLINE_LENGTH"
      :max-hidden-profile-length="MAX_HIDDEN_PROFILE_LENGTH"
      :max-prompt-length="MAX_PROMPT_LENGTH"
      :is-ai-magician-loading="isAIMagicianLoading.value"
      :ai-magician-error="aiMagicianError"
      :ai-magician-remaining-usage="aiMagicianRemainingUsage"
      :ai-magician-total-usage="AI_MAGICIAN_LIMIT"
      @open-ai-magician="openAIMagician"
      @update:name="personaForm.name = $event"
      @update:tagline="personaForm.tagline = $event"
      @update:hidden-profile="personaForm.hiddenProfile = $event"
      @update:prompt="personaForm.prompt = $event"
    />

    <GeneratingFooter
      v-if="currentStep !== Step.PROGRESS || isComplete"
      :confirm-button-label="confirmButtonLabel"
      :is-confirm-disabled="isConfirmDisabled"
      @confirm="handleConfirm"
    />
  </div>
</template>

<style scoped>
.generating {
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  padding: 20px 18px 28px;
  background: radial-gradient(
      115% 115% at 50% 0%,
      rgba(255, 64, 146, 0.2),
      rgba(10, 10, 10, 0.92) 65%
    ),
    #070707;
  color: #ffffff;
}

.generating--complete {
  background: linear-gradient(
      180deg,
      rgba(255, 255, 255, 0.04) 0%,
      rgba(7, 7, 7, 0.9) 65%
    ),
    #060606;
}

.generating--settings {
  padding-bottom: 48px;
  background: radial-gradient(
      150% 120% at 50% 0%,
      rgba(255, 84, 162, 0.18),
      rgba(5, 5, 5, 0.95) 80%
    ),
    #050505;
}

@media (min-width: 640px) {
  .generating {
    padding: 32px 24px 40px;
  }
}
</style>
