import { Router } from "express";
import logger from "../utils/logger.js";
import { requireFirebaseAuth } from "../auth/firebaseAuth.middleware.js";
import { validateRequest } from "../middleware/validation.middleware.js";
import { characterCreationSchemas } from "./characterCreation.schemas.js";
import {
  sendSuccess,
  sendError,
  ApiError,
} from "../../../shared/utils/errorFormatter.js";
import {
  createCreationFlow,
  getCreationFlow,
  mergeCreationFlow,
  recordCreationCharge,
  generateCreationResult,
} from "./characterCreation.service.js";
import {
  getUserGenerationLogs,
  getGenerationLog,
  getFlowGenerationLog,
  getAllGenerationLogs,
  getGenerationStats,
} from "./generationLog.service.js";
import {
  canCreateCharacter,
  getCreationStats,
} from "./characterCreationLimit.service.js";
import { consumeUserAsset } from "../user/assets.service.js";

const characterCreationRouter = Router();

const isoNow = () => new Date().toISOString();

const trimString = (value) =>
  typeof value === "string" ? value.trim() : "";

characterCreationRouter.post(
  "/flows",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.createFlow),
  async (req, res, next) => {
    try {
      // ğŸ”’ å¾èªè­‰ token ç²å– userIdï¼Œé˜²æ­¢å½é€ 
      const userId = req.firebaseUser.uid;

      const flow = await createCreationFlow({
        userId,
        persona: req.body?.persona,
        appearance: req.body?.appearance,
        voice: req.body?.voice,
        status: req.body?.status,
        metadata: req.body?.metadata,
      });
      sendSuccess(res, { flow }, 201);
    } catch (error) {
      logger.error("å»ºç«‹è§’è‰²å‰µå»ºæµç¨‹å¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.get(
  "/flows/:flowId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.getFlow),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const flow = await getCreationFlow(req.params.flowId);

      if (!flow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", {
          flowId: req.params.flowId,
        });
      }

      // ğŸ”’ é©—è­‰ç”¨æˆ¶åªèƒ½è¨ªå•è‡ªå·±çš„å‰µå»ºæµç¨‹
      if (flow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šè¨ªå•æ­¤å‰µå»ºæµç¨‹", {
          flowId: req.params.flowId,
        });
      }

      sendSuccess(res, { flow });
    } catch (error) {
      logger.error("æŸ¥è©¢è§’è‰²å‰µå»ºæµç¨‹å¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.patch(
  "/flows/:flowId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.updateFlow),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const existingFlow = await getCreationFlow(req.params.flowId);

      if (!existingFlow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", {
          flowId: req.params.flowId,
        });
      }

      // ğŸ”’ é©—è­‰ç”¨æˆ¶åªèƒ½æ›´æ–°è‡ªå·±çš„å‰µå»ºæµç¨‹
      if (existingFlow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šæ›´æ–°æ­¤å‰µå»ºæµç¨‹", {
          flowId: req.params.flowId,
        });
      }

      const flow = await mergeCreationFlow(req.params.flowId, req.body ?? {});
      sendSuccess(res, { flow });
    } catch (error) {
      logger.error("æ›´æ–°è§’è‰²å‰µå»ºæµç¨‹å¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.post(
  "/flows/:flowId/steps/:stepId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.updateStep),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const step = trimString(req.params.stepId).toLowerCase();
      const flowId = req.params.flowId;

      if (!step) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘æ­¥é©Ÿè­˜åˆ¥ç¢¼", {
          field: "stepId",
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™
      const currentFlow = await getCreationFlow(flowId);
      if (!currentFlow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", { flowId });
      }

      if (currentFlow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šè¨ªå•æ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      let payload = null;

      if (step === "persona") {
        payload = { persona: req.body ?? {} };
      } else if (step === "appearance") {
        payload = { appearance: req.body ?? {} };
      } else if (step === "voice") {
        payload = { voice: req.body ?? {} };
      } else {
        return sendError(res, "RESOURCE_NOT_FOUND", "æœªçŸ¥çš„è§’è‰²å‰µå»ºæ­¥é©Ÿ", {
          step,
          validSteps: ["persona", "appearance", "voice"],
        });
      }

      const flow = await mergeCreationFlow(flowId, payload);
      sendSuccess(res, { flow });
    } catch (error) {
      logger.error("æ›´æ–°å‰µå»ºæ­¥é©Ÿå¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.post(
  "/flows/:flowId/charges",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.recordCharge),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const flowId = req.params.flowId;

      // ğŸ”’ é©—è­‰æ¬Šé™
      const currentFlow = await getCreationFlow(flowId);
      if (!currentFlow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", { flowId });
      }

      if (currentFlow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šè¨ªå•æ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      const idempotencyKey =
        trimString(req.get("Idempotency-Key")) ||
        trimString(req.body?.idempotencyKey) ||
        null;

      const payload = {
        ...req.body,
        idempotencyKey,
      };

      const { flow, charge } = await recordCreationCharge(
        flowId,
        payload
      );

      sendSuccess(res, { flow, charge }, 201);
    } catch (error) {
      logger.error("è¨˜éŒ„ç”Ÿæˆè²»ç”¨å¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.post(
  "/flows/:flowId/generate",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.generateVoice),
  async (req, res, next) => {
    const userId = req.firebaseUser.uid;
    const flowId = req.params.flowId;

    try {
      const currentFlow = await getCreationFlow(flowId);
      if (!currentFlow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", {
          flowId,
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™
      if (currentFlow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šè¨ªå•æ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      if (!currentFlow.voice || !currentFlow.voice.id) {
        return sendError(res, "VALIDATION_ERROR", "å°šæœªé¸æ“‡è§’è‰²èªéŸ³ï¼Œç„¡æ³•é–‹å§‹ç”Ÿæˆæµç¨‹", {
          flowId,
          hasVoice: !!currentFlow.voice,
        });
      }

      const requestedKey =
        trimString(req.get("Idempotency-Key")) ||
        trimString(req.body?.idempotencyKey) ||
        null;

      const chargePayload =
        req.body?.charge && typeof req.body.charge === "object"
          ? { ...req.body.charge }
          : {
              type: "llm-generation",
              amount: Number.isFinite(req.body?.chargeAmount)
                ? Number(req.body.chargeAmount)
                : 0,
              currency:
                trimString(req.body?.chargeCurrency) ||
                "credits",
              metadata:
                req.body?.chargeMetadata &&
                typeof req.body.chargeMetadata === "object"
                  ? { ...req.body.chargeMetadata }
                  : undefined,
            };

      const previewBase =
        typeof req.body?.previewBaseUrl === "string"
          ? req.body.previewBaseUrl.replace(/\/+$/, "")
          : "";

      // æº–å‚™ç”Ÿæˆè¼¸å…¥åƒæ•¸ï¼ˆç”¨æ–¼è¨˜éŒ„ï¼‰
      const generationInput = {
        gender: currentFlow.metadata?.gender || "",
        description: currentFlow.appearance?.description || "",
        styles: currentFlow.appearance?.styles || [],
        referenceInfo: currentFlow.appearance?.referenceInfo || null,
      };

      const { flow, reused } = await generateCreationResult(flowId, {
        idempotencyKey: requestedKey ?? flowId,
        charge: chargePayload,
        generationInput,
        generator: async ({ flow: flowSnapshot }) => {
          const voiceId = flowSnapshot.voice?.id ?? "";
          const previewUrl = voiceId
            ? previewBase
              ? `${previewBase}/${voiceId}.mp3`
              : null
            : null;

          return {
            flowId: flowSnapshot.id,
            voice: { ...flowSnapshot.voice },
            assets: {
              previewUrl,
            },
            placeholder: true,
            generatedAt: isoNow(),
          };
        },
        statusOnStart: "generating",
        statusOnSuccess:
          trimString(req.body?.statusOnSuccess) || "completed",
        statusOnFailure:
          trimString(req.body?.statusOnFailure) || "failed",
      });

      sendSuccess(res, { flow, reused }, reused ? 200 : 201);
    } catch (error) {
      logger.error("èªéŸ³ç”Ÿæˆæµç¨‹å¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.post(
  "/flows/:flowId/ai-magician",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.aiMagician),
  async (req, res, next) => {
    const userId = req.firebaseUser.uid;
    const flowId = req.params.flowId;

    try {
      const currentFlow = await getCreationFlow(flowId);
      if (!currentFlow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", {
          flowId,
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™
      if (currentFlow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šè¨ªå•æ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      // æª¢æŸ¥æ˜¯å¦æœ‰é¸æ“‡è§’è‰²å¤–è§€ï¼ˆåœ–ç‰‡ï¼‰
      if (!currentFlow.appearance || !currentFlow.appearance.image) {
        return sendError(res, "VALIDATION_ERROR", "å°šæœªé¸æ“‡è§’è‰²å¤–è§€,ç„¡æ³•ä½¿ç”¨ AI é­”æ³•å¸«", {
          flowId,
          hasAppearance: !!currentFlow.appearance,
          hasImage: !!currentFlow.appearance?.image,
        });
      }

      const { generateCharacterPersona } = await import("./characterCreation.ai.js");

      // å¾ flow ä¸­ç²å–é¸å®šçš„ç…§ç‰‡URLã€æ€§åˆ¥å’Œé¢¨æ ¼
      const selectedImageUrl = currentFlow.appearance.image; // ç”¨æˆ¶é¸æ“‡çš„ç…§ç‰‡URL
      const gender = currentFlow.metadata?.gender || "";
      const styles = Array.isArray(currentFlow.appearance.styles)
        ? currentFlow.appearance.styles
        : [];

      const persona = await generateCharacterPersona({
        appearance: currentFlow.appearance,
        gender,
        styles,
        selectedImageUrl, // å‚³éé¸å®šçš„ç…§ç‰‡URLçµ¦ Vision API
      });

      sendSuccess(res, { persona });
    } catch (error) {
      logger.error("AI é­”æ³•å¸«ç”Ÿæˆå¤±æ•—:", error);
      next(error);
    }
  }
);

// AI æè¿°ç”Ÿæˆï¼ˆç„¡éœ€ flowIdï¼Œç”¨æ–¼ä»˜æ¬¾å‰çš„ AI é­”è¡“å¸«ï¼‰
// ä½¿ç”¨æ¬¡æ•¸è¿½è¹¤ç”±å‰ç«¯ sessionStorage è™•ç†
characterCreationRouter.post(
  "/ai-description",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.aiDescription),
  async (req, res, next) => {
    try {
      // ğŸ”’ é©—è­‰ç”¨æˆ¶å·²ç™»å…¥ï¼ˆä¸éœ€è¦é¡å¤–æ¬Šé™æª¢æŸ¥ï¼Œä»»ä½•ç™»å…¥ç”¨æˆ¶éƒ½å¯ä½¿ç”¨ï¼‰
      const userId = req.firebaseUser.uid;

      const gender = trimString(req.body?.gender);
      const styles = Array.isArray(req.body?.styles)
        ? req.body.styles
        : [];
      const referenceInfo = req.body?.referenceInfo || null;

      const { generateAppearanceDescription } = await import("./characterCreation.ai.js");

      const description = await generateAppearanceDescription({
        gender,
        styles,
        referenceInfo,
      });

      sendSuccess(res, { description });
    } catch (error) {
      logger.error("AI æè¿°ç”Ÿæˆå¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.post(
  "/flows/:flowId/ai-description",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.aiDescriptionWithFlow),
  async (req, res, next) => {
    const userId = req.firebaseUser.uid;
    const flowId = req.params.flowId;

    try {
      // ç²å–ä¸¦æª¢æŸ¥ flow
      const flow = await getCreationFlow(flowId);
      if (!flow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°è§’è‰²å‰µå»ºæµç¨‹", {
          flowId,
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™
      if (flow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šè¨ªå•æ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      // æª¢æŸ¥ AI é­”æ³•å¸«ä½¿ç”¨æ¬¡æ•¸é™åˆ¶ï¼ˆæ¯å€‹å‰µå»ºæµç¨‹é™3æ¬¡ï¼‰
      const AI_MAGICIAN_LIMIT = 3;
      const usageCount = flow.metadata?.aiMagicianUsageCount || 0;

      if (usageCount >= AI_MAGICIAN_LIMIT) {
        return sendError(res, "RATE_LIMIT_EXCEEDED", `AI é­”æ³•å¸«ä½¿ç”¨æ¬¡æ•¸å·²é”ä¸Šé™ï¼ˆ${AI_MAGICIAN_LIMIT} æ¬¡ï¼‰`, {
          usageCount,
          limit: AI_MAGICIAN_LIMIT,
          flowId,
        });
      }

      const gender = trimString(req.body?.gender);
      const styles = Array.isArray(req.body?.styles)
        ? req.body.styles
        : [];
      const referenceInfo = req.body?.referenceInfo || null;

      const { generateAppearanceDescription } = await import("./characterCreation.ai.js");

      const description = await generateAppearanceDescription({
        gender,
        styles,
        referenceInfo,
      });

      // æˆåŠŸç”Ÿæˆå¾Œå¢åŠ ä½¿ç”¨æ¬¡æ•¸
      await mergeCreationFlow(flowId, {
        metadata: {
          ...flow.metadata,
          aiMagicianUsageCount: usageCount + 1,
        },
      });

      const newUsageCount = usageCount + 1;
      const remainingUsage = AI_MAGICIAN_LIMIT - newUsageCount;

      sendSuccess(res, {
        description,
        usageCount: newUsageCount,
        remainingUsage,
        limit: AI_MAGICIAN_LIMIT,
      });
    } catch (error) {
      logger.error("AI é­”æ³•å¸«ç”Ÿæˆå½¢è±¡æè¿°å¤±æ•—:", error);
      next(error);
    }
  }
);

characterCreationRouter.post(
  "/flows/:flowId/generate-images",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.generateImages),
  async (req, res, next) => {
    const userId = req.firebaseUser.uid;
    const flowId = req.params.flowId;

    if (process.env.NODE_ENV !== "test") {
      logger.info(`[Image Generation API] Request received for flowId: ${flowId}`);
    }

    try {
      const currentFlow = await getCreationFlow(flowId);

      if (process.env.NODE_ENV !== "test") {
        logger.debug(`[Image Generation API] Flow found:`, {
          id: currentFlow?.id,
          status: currentFlow?.status,
          hasAppearance: !!currentFlow?.appearance,
          hasDescription: !!currentFlow?.appearance?.description,
        });
      }

      if (!currentFlow) {
        if (process.env.NODE_ENV !== "test") {
          logger.error(`[Image Generation API] Flow not found: ${flowId}`);
        }
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", {
          flowId,
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™
      if (currentFlow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šè¨ªå•æ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      if (!currentFlow.appearance || !currentFlow.appearance.description) {
        if (process.env.NODE_ENV !== "test") {
          logger.error(`[Image Generation API] Missing appearance data:`, {
            hasAppearance: !!currentFlow.appearance,
            hasDescription: !!currentFlow?.appearance?.description,
          });
        }
        return sendError(res, "VALIDATION_ERROR", "å°šæœªå¡«å¯«è§’è‰²å½¢è±¡æè¿°ï¼Œç„¡æ³•é–‹å§‹ç”Ÿæˆåœ–ç‰‡", {
          flowId,
          hasAppearance: !!currentFlow.appearance,
          hasDescription: !!currentFlow?.appearance?.description,
        });
      }

      // âœ… æª¢æŸ¥æ˜¯å¦å·²ç¶“ç”Ÿæˆéåœ–ç‰‡ï¼ˆä¸€å€‹å‰µå»ºæµç¨‹åªèƒ½ç”Ÿæˆä¸€æ¬¡ï¼‰
      if (
        currentFlow.generation.status === "completed" &&
        currentFlow.generation.result?.images &&
        currentFlow.generation.result.images.length > 0
      ) {
        logger.info(`[åœ–ç‰‡ç”Ÿæˆ] ç”¨æˆ¶ ${currentFlow.userId} å·²ç”Ÿæˆéåœ–ç‰‡ï¼Œç›´æ¥è¿”å›ä¹‹å‰çš„çµæœ`);
        return sendSuccess(res, {
          flow: currentFlow,
          reused: true,
          images: currentFlow.generation.result.images,
        });
      }

      // ç²å–ç”¨æˆ¶ ID ä¸¦æª¢æŸ¥å‰µå»ºè³‡æº
      const userId = currentFlow.userId;
      let shouldRecordCreation = false;
      let needsCreateCard = false;

      if (userId) {
        const { canCreateCharacter, getCreationStats } = await import("./characterCreationLimit.service.js");
        const { consumeUserAsset } = await import("../user/assets.service.js");

        const limitCheck = await canCreateCharacter(userId);
        if (!limitCheck.allowed) {
          return sendError(res, "PERMISSION_DENIED", limitCheck.message || "å·²é”åˆ°è§’è‰²å‰µå»ºæ¬¡æ•¸é™åˆ¶", {
            userId,
            limit: limitCheck,
          });
        }

        // æª¢æŸ¥æ˜¯å¦éœ€è¦ä½¿ç”¨å‰µå»ºå¡
        try {
          const stats = await getCreationStats(userId);

          if (stats.remaining <= 0) {
            // å…è²»æ¬¡æ•¸ç”¨å®Œï¼Œéœ€è¦ä½¿ç”¨å‰µå»ºå¡
            logger.info(`[åœ–ç‰‡ç”Ÿæˆ] ç”¨æˆ¶ ${userId} å…è²»æ¬¡æ•¸å·²ç”¨å®Œï¼ˆå‰©é¤˜ ${stats.remaining}ï¼‰ï¼Œå°‡åœ¨ç”ŸæˆæˆåŠŸå¾Œæ‰£é™¤å‰µå»ºå¡`);
            needsCreateCard = true;
            shouldRecordCreation = true;
          } else {
            // æœ‰å…è²»æ¬¡æ•¸
            logger.info(`[åœ–ç‰‡ç”Ÿæˆ] ç”¨æˆ¶ ${userId} ä½¿ç”¨å…è²»æ¬¡æ•¸ï¼ˆå‰©é¤˜ ${stats.remaining} æ¬¡ï¼‰`);
            shouldRecordCreation = true;
          }
        } catch (error) {
          logger.error(`[åœ–ç‰‡ç”Ÿæˆ] æª¢æŸ¥å‰µå»ºè³‡æºå¤±æ•—: ${error.message}`);
          return sendError(res, "INTERNAL_SERVER_ERROR", "æª¢æŸ¥å‰µå»ºè³‡æºå¤±æ•—", {
            userId,
            error: error.message,
          });
        }
      }

      const requestedKey =
        trimString(req.get("Idempotency-Key")) ||
        trimString(req.body?.idempotencyKey) ||
        null;

      const quality = trimString(req.body?.quality) || "high";
      const count = Number(req.body?.count) || 4;

      const chargePayload =
        req.body?.charge && typeof req.body.charge === "object"
          ? { ...req.body.charge }
          : {
              type: "image-generation",
              amount: Number.isFinite(req.body?.chargeAmount)
                ? Number(req.body.chargeAmount)
                : 0,
              currency:
                trimString(req.body?.chargeCurrency) ||
                "credits",
              metadata:
                req.body?.chargeMetadata &&
                typeof req.body.chargeMetadata === "object"
                  ? { ...req.body.chargeMetadata }
                  : undefined,
            };

      // æº–å‚™ç”Ÿæˆè¼¸å…¥åƒæ•¸ï¼ˆç”¨æ–¼è¨˜éŒ„ï¼‰
      const generationInput = {
        gender: currentFlow.metadata?.gender || "",
        description: currentFlow.appearance?.description || "",
        styles: currentFlow.appearance?.styles || [],
        referenceInfo: currentFlow.appearance?.referenceInfo || null,
      };

      const { flow, reused } = await generateCreationResult(flowId, {
        idempotencyKey: requestedKey ?? `${flowId}-images`,
        charge: chargePayload,
        generationInput,
        generator: async ({ flow: flowSnapshot }) => {
          const { generateCharacterImages } = await import("./characterCreation.ai.js");

          const result = await generateCharacterImages({
            gender: flowSnapshot.metadata?.gender || "",
            description: flowSnapshot.appearance?.description || "",
            styles: flowSnapshot.appearance?.styles || [],
            referenceInfo: flowSnapshot.appearance?.referenceInfo || null,
            quality,
            count,
            flowId: flowSnapshot.id,
            userId: flowSnapshot.userId,
          });

          return {
            flowId: flowSnapshot.id,
            images: result.images,
            prompt: result.prompt,
            metadata: result.metadata,
            generatedAt: isoNow(),
          };
        },
        statusOnStart: "generating",
        statusOnSuccess:
          trimString(req.body?.statusOnSuccess) || "appearance",
        statusOnFailure:
          trimString(req.body?.statusOnFailure) || "failed",
      });

      // ç”ŸæˆæˆåŠŸå¾Œæ‰£é™¤å‰µå»ºå¡ä¸¦é‡ç½® AI é­”è¡“å¸«ä½¿ç”¨æ¬¡æ•¸
      if (!reused && userId && shouldRecordCreation) {
        const { consumeUserAsset } = await import("../user/assets.service.js");
        const { getFirestoreDb } = await import("../firebase/index.js");

        // æ­¥é©Ÿ 1: ä½¿ç”¨ Transaction åŸå­æ€§åœ°è¨­ç½®æ¨™è¨˜ï¼ˆé˜²æ­¢ä¸¦ç™¼è¦†è“‹ï¼‰
        const db = getFirestoreDb();
        const flowRef = db.collection("character_creation_flows").doc(flowId);

        let latestFlowMetadata;
        try {
          await db.runTransaction(async (transaction) => {
            const flowDoc = await transaction.get(flowRef);

            if (!flowDoc.exists) {
              throw new Error('å‰µå»ºæµç¨‹ä¸å­˜åœ¨');
            }

            const flowData = flowDoc.data();
            const currentMetadata = flowData.metadata || {};

            // âš ï¸ æª¢æŸ¥æ˜¯å¦å·²ç¶“æ¨™è¨˜ç‚ºå·²æ‰£é™¤
            if (currentMetadata.deductedOnImageGeneration === true) {
              throw new Error('æ­¤æµç¨‹å·²ç¶“æ‰£é™¤éå‰µå»ºå¡ï¼Œè«‹å‹¿é‡è¤‡æäº¤');
            }

            // åŸå­æ€§åœ°è¨­ç½®æ¨™è¨˜
            const newMetadata = {
              ...currentMetadata,
              aiMagicianUsageCount: 0,
              deductedOnImageGeneration: needsCreateCard,
            };

            transaction.update(flowRef, {
              metadata: newMetadata,
              updatedAt: new Date().toISOString(),
            });

            latestFlowMetadata = newMetadata;
          });

          logger.info(`[åœ–ç‰‡ç”Ÿæˆ] æˆåŠŸè¨­ç½®æ‰£é™¤æ¨™è¨˜ï¼ŒneedsCreateCard: ${needsCreateCard}`);
        } catch (transactionError) {
          logger.error("[åœ–ç‰‡ç”Ÿæˆ] è¨­ç½®æ‰£é™¤æ¨™è¨˜å¤±æ•—:", transactionError);
          throw new Error(transactionError.message || "è¨­ç½®æ‰£é™¤æ¨™è¨˜å¤±æ•—ï¼Œè«‹é‡è©¦");
        }

        // æ­¥é©Ÿ 2: æ‰£é™¤å‰µå»ºå¡ï¼ˆç¨ç«‹çš„ Transactionï¼‰
        try {
          if (needsCreateCard) {
            await consumeUserAsset(userId, "createCards", 1);
            logger.info(`[åœ–ç‰‡ç”Ÿæˆ] ç”¨æˆ¶ ${userId} æˆåŠŸæ‰£é™¤ 1 å¼µå‰µå»ºå¡`);
          }
          logger.info(`[åœ–ç‰‡ç”Ÿæˆ] ç”¨æˆ¶ ${userId} åœ–ç‰‡ç”ŸæˆæˆåŠŸï¼ŒAI é­”è¡“å¸«æ¬¡æ•¸å·²é‡ç½®${needsCreateCard ? 'ï¼Œå‰µå»ºå¡å·²æ‰£é™¤' : ''}`);
        } catch (error) {
          // æ­¥é©Ÿ 3: å¦‚æœæ‰£é™¤å¤±æ•—ï¼Œä½¿ç”¨ Transaction å›æ»¾æ¨™è¨˜
          logger.error("[åœ–ç‰‡ç”Ÿæˆ] æ‰£é™¤å‰µå»ºå¡å¤±æ•—ï¼Œå›æ»¾æ¨™è¨˜:", error);

          try {
            await db.runTransaction(async (transaction) => {
              const flowDoc = await transaction.get(flowRef);

              if (flowDoc.exists) {
                const flowData = flowDoc.data();
                transaction.update(flowRef, {
                  metadata: {
                    ...(flowData.metadata || {}),
                    deductedOnImageGeneration: false,
                  },
                  updatedAt: new Date().toISOString(),
                });
              }
            });
            logger.info("[åœ–ç‰‡ç”Ÿæˆ] æˆåŠŸå›æ»¾æ‰£é™¤æ¨™è¨˜");
          } catch (rollbackError) {
            logger.error("[åœ–ç‰‡ç”Ÿæˆ] å›æ»¾æ¨™è¨˜å¤±æ•—:", rollbackError);
          }

          throw new Error("å‰µå»ºå¡æ‰£é™¤å¤±æ•—ï¼Œè«‹é‡è©¦");
        }
      }

      sendSuccess(res, {
        flow,
        reused,
        images: flow.generation?.result?.images || [],
      }, reused ? 200 : 201);
    } catch (error) {
      logger.error("åœ–åƒç”Ÿæˆæµç¨‹å¤±æ•—:", error);
      next(error);
    }
  }
);

// æŸ¥è©¢ç”¨æˆ¶çš„ç”Ÿæˆè¨˜éŒ„
characterCreationRouter.get(
  "/generation-logs/user/:userId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.userGenerationLogs),
  (req, res, next) => {
    try {
      const currentUserId = req.firebaseUser.uid;
      const requestedUserId = trimString(req.params.userId);
      const limit = Number(req.query.limit) || 50;
      const offset = Number(req.query.offset) || 0;

      if (!requestedUserId) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘ç”¨æˆ¶ID", {
          field: "userId",
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™ï¼šç”¨æˆ¶åªèƒ½æŸ¥çœ‹è‡ªå·±çš„è¨˜éŒ„
      if (requestedUserId !== currentUserId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬ŠæŸ¥çœ‹ä»–äººçš„ç”Ÿæˆè¨˜éŒ„", {
          requestedUserId,
        });
      }

      const logs = getUserGenerationLogs(requestedUserId, { limit, offset });
      sendSuccess(res, { logs, count: logs.length });
    } catch (error) {
      logger.error("æŸ¥è©¢ç”¨æˆ¶ç”Ÿæˆè¨˜éŒ„å¤±æ•—:", error);
      next(error);
    }
  }
);

// æŸ¥è©¢å–®å€‹ç”Ÿæˆè¨˜éŒ„
characterCreationRouter.get(
  "/generation-logs/:logId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.generationLog),
  (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const logId = trimString(req.params.logId);
      if (!logId) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘è¨˜éŒ„ID", {
          field: "logId",
        });
      }

      const log = getGenerationLog(logId);
      if (!log) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°ç”Ÿæˆè¨˜éŒ„", {
          logId,
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™ï¼šç”¨æˆ¶åªèƒ½æŸ¥çœ‹è‡ªå·±çš„è¨˜éŒ„
      if (log.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬ŠæŸ¥çœ‹ä»–äººçš„ç”Ÿæˆè¨˜éŒ„", { logId });
      }

      sendSuccess(res, { log });
    } catch (error) {
      logger.error("æŸ¥è©¢ç”Ÿæˆè¨˜éŒ„å¤±æ•—:", error);
      next(error);
    }
  }
);

// æŸ¥è©¢æµç¨‹çš„ç”Ÿæˆè¨˜éŒ„
characterCreationRouter.get(
  "/generation-logs/flow/:flowId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.flowGenerationLog),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const flowId = trimString(req.params.flowId);
      if (!flowId) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘æµç¨‹ID", {
          field: "flowId",
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™ï¼šæª¢æŸ¥ flow æ‰€æœ‰æ¬Š
      const flow = await getCreationFlow(flowId);
      if (!flow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", { flowId });
      }

      if (flow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬ŠæŸ¥çœ‹æ­¤æµç¨‹çš„ç”Ÿæˆè¨˜éŒ„", { flowId });
      }

      const log = getFlowGenerationLog(flowId);
      if (!log) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æµç¨‹çš„ç”Ÿæˆè¨˜éŒ„", {
          flowId,
        });
      }

      sendSuccess(res, { log });
    } catch (error) {
      logger.error("æŸ¥è©¢æµç¨‹ç”Ÿæˆè¨˜éŒ„å¤±æ•—:", error);
      next(error);
    }
  }
);

// æŸ¥è©¢æ‰€æœ‰ç”Ÿæˆè¨˜éŒ„ï¼ˆç®¡ç†ç”¨ï¼‰
// TODO: å¾ŒçºŒéœ€è¦æ·»åŠ ç®¡ç†å“¡æ¬Šé™é©—è­‰
characterCreationRouter.get(
  "/generation-logs",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.allGenerationLogs),
  (req, res, next) => {
    try {
      // ğŸ”’ åŸºç¤èªè­‰ï¼šç›®å‰åªè¦æ±‚ç™»å…¥ï¼Œæœªä¾†å¯æ·»åŠ ç®¡ç†å“¡æ¬Šé™æª¢æŸ¥
      const userId = req.firebaseUser.uid;

      const limit = Number(req.query.limit) || 50;
      const offset = Number(req.query.offset) || 0;
      const status = trimString(req.query.status) || null;

      const result = getAllGenerationLogs({ limit, offset, status });
      sendSuccess(res, result);
    } catch (error) {
      logger.error("æŸ¥è©¢ç”Ÿæˆè¨˜éŒ„å¤±æ•—:", error);
      next(error);
    }
  }
);

// æŸ¥è©¢æ‰€æœ‰ç”Ÿæˆçµ±è¨ˆ
// TODO: å¾ŒçºŒéœ€è¦æ·»åŠ ç®¡ç†å“¡æ¬Šé™é©—è­‰
characterCreationRouter.get(
  "/generation-stats",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.generationStats),
  (req, res, next) => {
    try {
      // ğŸ”’ åŸºç¤èªè­‰ï¼šç›®å‰åªè¦æ±‚ç™»å…¥ï¼Œæœªä¾†å¯æ·»åŠ ç®¡ç†å“¡æ¬Šé™æª¢æŸ¥
      const userId = req.firebaseUser.uid;

      const stats = getGenerationStats(null);
      sendSuccess(res, { stats });
    } catch (error) {
      logger.error("æŸ¥è©¢ç”Ÿæˆçµ±è¨ˆå¤±æ•—:", error);
      next(error);
    }
  }
);

// æŸ¥è©¢æŒ‡å®šç”¨æˆ¶çš„ç”Ÿæˆçµ±è¨ˆ
characterCreationRouter.get(
  "/generation-stats/user/:userId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.userGenerationStats),
  (req, res, next) => {
    try {
      const currentUserId = req.firebaseUser.uid;
      const requestedUserId = trimString(req.params.userId);
      if (!requestedUserId) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘ç”¨æˆ¶ID", {
          field: "userId",
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™ï¼šç”¨æˆ¶åªèƒ½æŸ¥çœ‹è‡ªå·±çš„çµ±è¨ˆ
      if (requestedUserId !== currentUserId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬ŠæŸ¥çœ‹ä»–äººçš„ç”Ÿæˆçµ±è¨ˆ", {
          requestedUserId,
        });
      }

      const stats = getGenerationStats(requestedUserId);
      sendSuccess(res, { stats });
    } catch (error) {
      logger.error("æŸ¥è©¢ç”Ÿæˆçµ±è¨ˆå¤±æ•—:", error);
      next(error);
    }
  }
);

// æŸ¥è©¢è§’è‰²å‰µå»ºé™åˆ¶
characterCreationRouter.get(
  "/limits/:userId",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.limits),
  async (req, res, next) => {
    try {
      const currentUserId = req.firebaseUser.uid;
      const requestedUserId = trimString(req.params.userId);
      if (!requestedUserId) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘ç”¨æˆ¶ID", {
          field: "userId",
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™ï¼šç”¨æˆ¶åªèƒ½æŸ¥çœ‹è‡ªå·±çš„é™åˆ¶
      if (requestedUserId !== currentUserId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬ŠæŸ¥çœ‹ä»–äººçš„å‰µå»ºé™åˆ¶", {
          requestedUserId,
        });
      }

      const limitCheck = await canCreateCharacter(requestedUserId);
      const creationStats = await getCreationStats(requestedUserId);

      if (process.env.NODE_ENV !== "test") {
        logger.info(`[å‰µå»ºè§’è‰²é™åˆ¶] ç”¨æˆ¶ ${requestedUserId} æŸ¥è©¢é™åˆ¶:`, {
          limitCheck,
          creationStats,
        });
      }

      sendSuccess(res, {
        limit: limitCheck,
        stats: creationStats,
        remainingFreeCreations: creationStats.remaining || 0,
      });
    } catch (error) {
      logger.error("æŸ¥è©¢è§’è‰²å‰µå»ºé™åˆ¶å¤±æ•—:", error);
      next(error);
    }
  }
);

// ä½¿ç”¨å‰µå»ºè§’è‰²å¡
// POST /api/character-creation/use-create-card
// ğŸ”’ å®‰å…¨å¢å¼·ï¼šå¾èªè­‰ token ç²å– userIdï¼Œé˜²æ­¢ç›œç”¨ä»–äººå‰µå»ºå¡
characterCreationRouter.post(
  "/use-create-card",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.useCreateCard),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;

      logger.info(`[å‰µå»ºè§’è‰²å¡] ç”¨æˆ¶ ${userId} è«‹æ±‚ä½¿ç”¨å‰µå»ºå¡`);

      // æ‰£é™¤ä¸€å¼µå‰µå»ºå¡ï¼ˆæœƒè‡ªå‹•æª¢æŸ¥æ•¸é‡ï¼‰
      const result = await consumeUserAsset(userId, "createCards", 1);

      logger.info(`[å‰µå»ºè§’è‰²å¡] ç”¨æˆ¶ ${userId} æˆåŠŸä½¿ç”¨äº† 1 å¼µå‰µå»ºè§’è‰²å¡`);

      sendSuccess(res, {
        message: "æˆåŠŸä½¿ç”¨å‰µå»ºè§’è‰²å¡",
        remainingCards: result.createCards || 0,
        deducted: 1,
      });
    } catch (error) {
      logger.error("ä½¿ç”¨å‰µå»ºè§’è‰²å¡å¤±æ•—:", error);
      next(error);
    }
  }
);

// æ¸…ç†æœªé¸ä¸­çš„è§’è‰²åœ–ç‰‡
// POST /api/character-creation/flows/:flowId/cleanup-images
// ç”¨æ–¼åˆªé™¤è§’è‰²å‰µå»ºéç¨‹ä¸­æœªè¢«é¸ä¸­çš„åœ–ç‰‡ï¼Œç¯€çœå„²å­˜ç©ºé–“
characterCreationRouter.post(
  "/flows/:flowId/cleanup-images",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.cleanupImages),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const { flowId } = req.params;
      const { selectedImageUrl, allImages } = req.body;

      if (!flowId) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘ flowId åƒæ•¸", {
          field: "flowId",
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™
      const flow = await getCreationFlow(flowId);
      if (!flow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", { flowId });
      }

      if (flow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šæ“ä½œæ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      if (!selectedImageUrl) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘ selectedImageUrl åƒæ•¸", {
          field: "selectedImageUrl",
        });
      }

      if (!Array.isArray(allImages) || allImages.length === 0) {
        return sendError(res, "VALIDATION_ERROR", "allImages å¿…é ˆæ˜¯éç©ºé™£åˆ—", {
          field: "allImages",
          providedType: Array.isArray(allImages) ? "empty array" : typeof allImages,
        });
      }

      logger.info(`[åœ–ç‰‡æ¸…ç†] é–‹å§‹æ¸…ç† flowId=${flowId} çš„æœªé¸ä¸­åœ–ç‰‡`);
      logger.info(`[åœ–ç‰‡æ¸…ç†] é¸ä¸­çš„åœ–ç‰‡: ${selectedImageUrl}`);
      logger.info(`[åœ–ç‰‡æ¸…ç†] æ‰€æœ‰åœ–ç‰‡æ•¸é‡: ${allImages.length}`);

      // æ‰¾å‡ºæœªé¸ä¸­çš„åœ–ç‰‡
      const unselectedImages = allImages.filter(url => url !== selectedImageUrl);

      logger.info(`[åœ–ç‰‡æ¸…ç†] éœ€è¦åˆªé™¤çš„åœ–ç‰‡æ•¸é‡: ${unselectedImages.length}`);

      if (unselectedImages.length === 0) {
        return sendSuccess(res, {
          deleted: 0,
          message: "æ²’æœ‰éœ€è¦åˆªé™¤çš„åœ–ç‰‡"
        });
      }

      // å‹•æ…‹å°å…¥ deleteImage å‡½æ•¸ä»¥é¿å…å¾ªç’°ä¾è³´
      const { deleteImage } = await import("../firebase/storage.service.js");

      // åˆªé™¤æ‰€æœ‰æœªé¸ä¸­çš„åœ–ç‰‡
      const deleteResults = await Promise.allSettled(
        unselectedImages.map(async (url) => {
          try {
            await deleteImage(url);
            logger.info(`[åœ–ç‰‡æ¸…ç†] æˆåŠŸåˆªé™¤: ${url}`);
            return { url, success: true };
          } catch (error) {
            logger.error(`[åœ–ç‰‡æ¸…ç†] åˆªé™¤å¤±æ•—: ${url}`, error);
            return { url, success: false, error: error.message };
          }
        })
      );

      // çµ±è¨ˆåˆªé™¤çµæœ
      const successCount = deleteResults.filter(r => r.status === "fulfilled" && r.value.success).length;
      const failCount = deleteResults.length - successCount;

      logger.info(`[åœ–ç‰‡æ¸…ç†] åˆªé™¤å®Œæˆ: æˆåŠŸ ${successCount} å€‹ï¼Œå¤±æ•— ${failCount} å€‹`);

      sendSuccess(res, {
        deleted: successCount,
        failed: failCount,
        total: unselectedImages.length,
        message: `æˆåŠŸåˆªé™¤ ${successCount} å¼µæœªé¸ä¸­çš„åœ–ç‰‡`
      });
    } catch (error) {
      logger.error("[åœ–ç‰‡æ¸…ç†] æ¸…ç†å¤±æ•—:", error);
      next(error);
    }
  }
);

// å–æ¶ˆè§’è‰²å‰µå»ºä¸¦æ¸…ç†æ‰€æœ‰ç”Ÿæˆçš„åœ–ç‰‡
// POST /api/character-creation/flows/:flowId/cancel
// ç”¨æ–¼ç”¨æˆ¶æ”¾æ£„å‰µå»ºæ™‚ï¼Œåˆªé™¤æ‰€æœ‰ç”Ÿæˆçš„åœ–ç‰‡ä¸¦æ¨™è¨˜æµç¨‹ç‚ºå·²å–æ¶ˆ
characterCreationRouter.post(
  "/flows/:flowId/cancel",
  requireFirebaseAuth,
  validateRequest(characterCreationSchemas.cancelFlow),
  async (req, res, next) => {
    try {
      const userId = req.firebaseUser.uid;
      const { flowId } = req.params;

      if (!flowId) {
        return sendError(res, "VALIDATION_ERROR", "ç¼ºå°‘ flowId åƒæ•¸", {
          field: "flowId",
        });
      }

      // ç²å– flow è³‡æ–™
      const flow = await getCreationFlow(flowId);
      if (!flow) {
        return sendError(res, "RESOURCE_NOT_FOUND", "æ‰¾ä¸åˆ°æŒ‡å®šçš„è§’è‰²å‰µå»ºæµç¨‹", {
          flowId,
        });
      }

      // ğŸ”’ é©—è­‰æ¬Šé™
      if (flow.userId !== userId) {
        return sendError(res, "FORBIDDEN", "ç„¡æ¬Šå–æ¶ˆæ­¤å‰µå»ºæµç¨‹", { flowId });
      }

      logger.info(`[å–æ¶ˆå‰µå»º] é–‹å§‹è™•ç† flowId=${flowId} çš„å–æ¶ˆè«‹æ±‚`);

      // ç²å–æ‰€æœ‰ç”Ÿæˆçš„åœ–ç‰‡
      const generatedImages = flow.generation?.result?.images || [];

      if (generatedImages.length > 0) {
        logger.info(`[å–æ¶ˆå‰µå»º] éœ€è¦åˆªé™¤ ${generatedImages.length} å¼µç”Ÿæˆçš„åœ–ç‰‡`);

        // å‹•æ…‹å°å…¥ deleteImage å‡½æ•¸
        const { deleteImage } = await import("../firebase/storage.service.js");

        // åˆªé™¤æ‰€æœ‰ç”Ÿæˆçš„åœ–ç‰‡
        const deleteResults = await Promise.allSettled(
          generatedImages.map(async (image) => {
            const url = typeof image === 'string' ? image : image.url;
            try {
              await deleteImage(url);
              logger.info(`[å–æ¶ˆå‰µå»º] æˆåŠŸåˆªé™¤åœ–ç‰‡: ${url}`);
              return { url, success: true };
            } catch (error) {
              logger.error(`[å–æ¶ˆå‰µå»º] åˆªé™¤åœ–ç‰‡å¤±æ•—: ${url}`, error);
              return { url, success: false, error: error.message };
            }
          })
        );

        // çµ±è¨ˆåˆªé™¤çµæœ
        const successCount = deleteResults.filter(r => r.status === "fulfilled" && r.value.success).length;
        const failCount = deleteResults.length - successCount;

        logger.info(`[å–æ¶ˆå‰µå»º] åœ–ç‰‡åˆªé™¤å®Œæˆ: æˆåŠŸ ${successCount} å€‹ï¼Œå¤±æ•— ${failCount} å€‹`);
      } else {
        logger.info(`[å–æ¶ˆå‰µå»º] æ²’æœ‰ç”Ÿæˆçš„åœ–ç‰‡éœ€è¦åˆªé™¤`);
      }

      // æ›´æ–° flow ç‹€æ…‹ç‚º cancelled
      const updatedFlow = await mergeCreationFlow(flowId, {
        status: "cancelled",
      });

      logger.info(`[å–æ¶ˆå‰µå»º] æµç¨‹å·²æ¨™è¨˜ç‚ºå·²å–æ¶ˆ: ${flowId}`);

      sendSuccess(res, {
        flow: updatedFlow,
        deletedImages: generatedImages.length,
        message: "è§’è‰²å‰µå»ºå·²å–æ¶ˆï¼Œç”Ÿæˆçš„åœ–ç‰‡å·²æ¸…ç†",
      });
    } catch (error) {
      logger.error("[å–æ¶ˆå‰µå»º] è™•ç†å¤±æ•—:", error);
      next(error);
    }
  }
);

export { characterCreationRouter };
